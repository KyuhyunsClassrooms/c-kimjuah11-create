# 1. 프로그램 설계서 (5점)

## 1. 프로젝트 주제
효율적인 공정 순서 짜기 (SPT 이용)

## 2. 핵심 기능 목록
(구현할 기능들을 순서대로 나열하세요.)
1.  직접 공정 개수와 이름, 소요 시간을 입력할 수 있다
2.  입력한 순서 그대로 작업이 처리된다고 가정하고, 화면에 각 공정의 진행 상황도 출력된다
3.  입력받은 공정들을 소요시간이 짧은 것에서 긴 것으로 정렬한다
4.  처리시간이 짧은 공정을 먼저 수행하는 SPT 순서와 사람이 입력한 순서의 평균 완료시간을 비교하고 어느 쪽이 더 효율적인지 분석 결과를 출력한다

## 3. 데이터 구조 설계
(프로그램에 필요한 핵심 변수, 배열을 설계하세요. 필요하면 구조체(struct)를 사용할 수도 있습니다.)

#include <stdio.h>
#include <string.h>

#define MAX_PROCS 20
#define NAME_LEN 32

typedef struct {
    char name[NAME_LEN];
    int time;
    int start;
    int finish;
} Process;

void input_processes(Process procs[], int *n);
void simulate_sequence(Process procs[], int n);
void copy_processes(Process src[], Process dest[], int n);
void sort_by_time(Process procs[], int n);
double average_completion_time(Process procs[], int n);

int main() {
    Process procs[MAX_PROCS];
    Process procs_opt[MAX_PROCS];
    int n = 0;

    printf("=== 공정 순서 시뮬레이터 ===\n");
    input_processes(procs, &n);

    printf("\n>> 입력 순서대로 시뮬레이션 결과\n");
    simulate_sequence(procs, n);
    double avg_user = average_completion_time(procs, n);
    printf("평균 완료 시간(입력 순서): %.2f 분\n", avg_user);

    copy_processes(procs, procs_opt, n);
    sort_by_time(procs_opt, n);

    printf("\n>> SPT(처리시간 짧은 순서)로 정렬한 시뮬레이션 결과\n");
    simulate_sequence(procs_opt, n);
    double avg_opt = average_completion_time(procs_opt, n);
    printf("평균 완료 시간(SPT): %.2f 분\n", avg_opt);

    printf("\n=== 비교 ===\n");
    printf("입력 순서 평균: %.2f 분 | SPT 평균: %.2f 분\n", avg_user, avg_opt);
    if (avg_opt < avg_user) {
        printf("=> SPT가 평균 완료시간을 %.2f 분만큼 개선합니다.\n", avg_user - avg_opt);
    } else {
        printf("=> 입력한 순서가 이미 효율적이거나 동일합니다.\n");
    }

    return 0;
}

void input_processes(Process procs[], int *n) {
    int i;
    printf("공정 개수 입력 (최대 %d): ", MAX_PROCS);
    scanf("%d", n);
    if (*n < 1) *n = 1;
    if (*n > MAX_PROCS) *n = MAX_PROCS;

    for (i = 0; i < *n; ++i) {
        printf("공정 %d 이름: ", i+1);
        scanf("%s", procs[i].name);
        printf("공정 %d 소요시간(분): ", i+1);
        scanf("%d", &procs[i].time);
        procs[i].start = -1;
        procs[i].finish = -1;
    }
}

void simulate_sequence(Process procs[], int n) {
    int time = 0;
    for (int i = 0; i < n; ++i) {
        procs[i].start = time;
        time += procs[i].time;
        procs[i].finish = time;
        printf("공정 %d: %-10s | 시작: %3d 분, 소요: %3d 분, 완료: %3d 분\n",
               i+1, procs[i].name, procs[i].start, procs[i].time, procs[i].finish);
    }
    printf("총 소요 시간: %d 분\n", time);
}

void copy_processes(Process src[], Process dest[], int n) {
    for (int i = 0; i < n; ++i) {
        strcpy(dest[i].name, src[i].name);
        dest[i].time = src[i].time;
        dest[i].start = src[i].start;
        dest[i].finish = src[i].finish;
    }
}

void sort_by_time(Process procs[], int n) {
    for (int i = 0; i < n-1; ++i) {
        int min_idx = i;
        for (int j = i+1; j < n; ++j) {
            if (procs[j].time < procs[min_idx].time) min_idx = j;
        }
        if (min_idx != i) {
            Process tmp = procs[i];
            procs[i] = procs[min_idx];
            procs[min_idx] = tmp;
        }
    }
}

double average_completion_time(Process procs[], int n) {
    double sum = 0.0;
    for (int i = 0; i < n; ++i) sum += procs[i].finish;
    return sum / n;
}
